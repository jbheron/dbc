# learning competencies


## testing and debugging
- Identify where the error is, decipher the error message, and infer the likely source of the error
- Know the solution to most common error messages,  and be able to explain succinctly why the error occurred 
- Use puts statements to view variable states and method returns to decipher non-obvious bugs 
- Create a succinct description of an error that will yield accurate search results
- Use a debugging tool to stop the program during runtime, access variable states, and step through line by line 
- Test code without attachment
- Infer the behavior and structure of code variables, methods, and objects accessed from test code
- Build test methods with descriptive output and clear indicators of passing tests
- Work with testing libraries like Rspec


## modeling
- Decompose a problem into smaller, easier-to-solve components 
- Diagram the relationship between the 'real world' and 'code'
- Elucidate the action of a method with a real world example
- Model a real world system using ruby code 
- Translate between different modes of modeling a problem (user stories, diagrams, pseudocode, etc.)
- Use Pseudocode effectively to model problem-solving
- Read Pseudocode and translate to code
- Identify limitations of model approximation of a problem
- Identify the possible states of a program and explain under what conditions it will enter each state 
- Build a wireframe to model application views


## programming basics
- Identify the basic components of programming (variables, conditionals, looping, methods, data types) when reading a program
- Read a program and evaluate the code in my head, easily identifying areas of confusion or unknown concepts
- Write code with accurate method definition, arguments, and return values
- Use Method Chaining to create concise readable code
- Use methods to modularize code
- Express the branching control structure in Ruby
- Express the looping control structure in Ruby
- Use nested loops, for loops, sentinel controlled loops (while and until)
- Use recursion
- Choose between recursion and iteration effectively
- Use regular expressions
- Use variables to maintain program state
- Work with input / output from the console
- Create interactive command-line applications with data persistence
- Implement a 'user session' for console input and store session data when necessary
- Effectively use standard Ruby classes


## ruby libraries, built-in classes and gems
- Use common methods from the String class effectively in code
- Research and understand the Enumerable methods
- Use ARGV to take in user input from the command line
- Properly reformat ARGV data to meet to program requirements
- Install a Gem
- Use the Nokogiri gem to parse CSS elements 
- Use the OpenURI built-in module or Net::HTTP   to download and read live html pages


## data structures
- Implement common data structures to map relationships
- Manipulate and access data in any of the common data structures 
- Determine when to use a particular data structure 
- Manipulate and access array data in simple and nested arrays 
- Implement the Linked List data structures in Ruby  
- Implement the Stack and Queue data structures in Ruby  


## algorithms
- Implement simple mathematical algorithms in Ruby 
- Choose an optimal sorting algorithm based on complexity, memory, and other factors 
- Sort a data structure using common sorting algorithms 


## refactor
- Organize code for consistency and readability 
- Recognize incorrect conventions and fix them without breaking the interface 
- Recognize the characteristics of good code and Best Practices, and implement these in code 
- Refactor poorly formatted code 
- Use effective naming conventions 
- Abstract a pattern for a model after identifying repetition in code and relationships in data 
- Write DRY code 
- Write small, concise, encapsulated methods 
- Explain the difference between refactoring and adding (or removing) domain logic 
- Apply common design patterns when refactoring code (Inheritance, Composition, MVC, etc. ) 


## research
- Read and understand another code base  
- Research development tools and understand when they are useful 
- Research best practices and integrate them into code 
- Use Ruby Docs to effectively research existing Ruby methods 
- Search the web for solutions to a problem and filter plausible solutions from implausible ones 



## development tools
- Use IRB effectively to test code assumptions 
- Use Sublime effectively, navigating with shortcuts 
- Use tools to evaluate basic performance considerations, benchmarking, and tradeoffs between memory and speed , 


## object oriented programming
- Use inheritance to model problems, and effectively implement inheritance in Ruby 
- Map data in a file from one format to another using Ruby 
- Choose the appropriate method to store data in a file  
- Create well-defined classes with a single responsibility 
- Identify and implement classes based on real world requirements 
- Implement clean and flexible interfaces between objects 
- Use composition to give structure to more complex objects 
- Map data within a given object (ie Nokogiri object) to a customized object 
- Identify trade-offs between inheritance and composition and refactor code from one format to the other  
- Use the design pattern of factory modules and methods to model problems 
- Use the model-view-controller pattern to organize code and decouple concerns 
- Decompose a problem in various dimensions including (but not limited to): separation of concerns, law of demeter, frequency of use, frequency of change, encapsulation, loose coupling, and the single-responsibility principle 


## database
- Design database schema from problem data 
- Model relationships in a relational database (one-to-one, one-to-many, many-to-many) 
- Create and modify a database in SQLite 
- Use SQLite and the SQLite console to query data 
- Use common SQL Queries to view specific data 
- Use sqlite gem to create a database using Ruby commands 
- Use sqlite gem to perform CRUD operations on tables in a database using Ruby commands 
- Use metaprogramming to create dynamic getters and setters in an ORM 
- Use Active Record Migrations to create a database 
- Use Active Record Queries to query a database 
- Use Active Record to create Associations between database tables 
- verify changes made by framework with SQL
- create an index and quantify the improvement it can provide
- Use Active Record callbacks
- Create a database index
- Describe common read / write performance tradeoffs associated with creating an index
- Use Active Record Validations


## learning
- Take full responsibility for my learning
- Articulate how I prefer learning, can recognize whether I am learning optimally, and can adjust the current context / approach to optimize my learning
- Pace my learning to maximize my understanding and engagement
- Articulate gaps in my knowledge given a set of clearly articulated learning objectives
- Articulate what I've learned to other students in a way that aids their understanding
- Do my very best. I prioritize my learning over everything else, and put 100% effort. I leave everything on the table to contribute to a passionate and motivated learning environment. In short, I kick my own ass, inspiring others to do the same


## collaboration
- Comfortably express myself clearly and concisely to my teammates
- Recognize and respond to my teammate's state of mind and emotional center
- Solicit and give effective feedback that is specific, actionable, and kind
- Act in a way that my peers feel respected and inspired by me
